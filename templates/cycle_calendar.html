{% extends "base.html" %}

{% block title %}Cycle Calendar - Cycliqe{% endblock %}

{% block content %}
<div class="calendar-container">
    <div class="calendar-header">
        <h1>Cycle Calendar</h1>
        <p>Track and visualize your menstrual cycle</p>
    </div>

    <div class="calendar-controls">
        <button id="prevMonth" class="btn-icon">
            <i class="fas fa-chevron-left"></i>
        </button>
        <h2 id="currentMonthYear" class="month-year">January 2024</h2>
        <button id="nextMonth" class="btn-icon">
            <i class="fas fa-chevron-right"></i>
        </button>
    </div>

    <div class="calendar-legend">
        <div class="legend-item">
            <span class="legend-color period"></span>
            <span>Period Days</span>
        </div>
        <div class="legend-item">
            <span class="legend-color predicted"></span>
            <span>Predicted Period</span>
        </div>
        <div class="legend-item">
            <span class="legend-color fertile"></span>
            <span>Fertile Window</span>
        </div>
        <div class="legend-item">
            <span class="legend-color ovulation"></span>
            <span>Ovulation Day</span>
        </div>
        <div class="legend-item">
            <span class="legend-color normal"></span>
            <span>Normal Days</span>
        </div>
    </div>

    <div class="calendar-wrapper">
        <div class="calendar-grid" id="calendarGrid">
            <!-- Calendar will be generated by JavaScript -->
        </div>
    </div>

    <div class="calendar-actions">
        <button id="logPeriodBtn" class="btn-primary">
            <i class="fas fa-plus"></i>
            Log Period Start
        </button>
        <button id="logEndBtn" class="btn-secondary">
            <i class="fas fa-check"></i>
            Log Period End
        </button>
    </div>

    <!-- Period Log Modal -->
    <div id="periodModal" class="modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2>Log Period</h2>
            <form id="periodForm">
                <div class="form-group">
                    <label>Start Date</label>
                    <input type="date" id="periodStartDate" required>
                </div>
                <div class="form-group">
                    <label>End Date (optional)</label>
                    <input type="date" id="periodEndDate">
                </div>
                <button type="submit" class="btn-primary btn-full">Save</button>
            </form>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    let currentDate = new Date();
    let selectedDate = null;

    // Initialize calendar
    document.addEventListener('DOMContentLoaded', function() {
        renderCalendar();
        // Wait a bit longer to ensure calendar is fully rendered
        setTimeout(() => {
            console.log('Loading cycle data...');
            loadCycleData();
        }, 300); // Increased delay
        
        document.getElementById('prevMonth').addEventListener('click', () => {
            currentDate.setMonth(currentDate.getMonth() - 1);
            renderCalendar();
            setTimeout(() => {
                console.log('Loading cycle data for previous month...');
                loadCycleData();
            }, 300); // Increased delay
        });
        
        document.getElementById('nextMonth').addEventListener('click', () => {
            currentDate.setMonth(currentDate.getMonth() + 1);
            renderCalendar();
            setTimeout(() => {
                console.log('Loading cycle data for next month...');
                loadCycleData();
            }, 300); // Increased delay
        });
        
        document.getElementById('logPeriodBtn').addEventListener('click', () => {
            document.getElementById('periodModal').style.display = 'block';
            document.getElementById('periodStartDate').valueAsDate = new Date();
        });
        
        document.querySelector('.close-modal').addEventListener('click', () => {
            document.getElementById('periodModal').style.display = 'none';
        });
        
        document.getElementById('periodForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const startDate = document.getElementById('periodStartDate').value;
            const endDate = document.getElementById('periodEndDate').value;
            
            try {
                const response = await fetch('/api/log-cycle', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({start_date: startDate, end_date: endDate})
                });
                
                const data = await response.json();
                if (data.success) {
                    alert('Period logged successfully!');
                    document.getElementById('periodModal').style.display = 'none';
                    loadCycleData();
                    renderCalendar();
                }
            } catch (error) {
                alert('Error logging period');
            }
        });
    });

    function renderCalendar() {
        const year = currentDate.getFullYear();
        const month = currentDate.getMonth();
        
        document.getElementById('currentMonthYear').textContent = 
            new Date(year, month).toLocaleDateString('en-US', {month: 'long', year: 'numeric'});
        
        const firstDay = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        
        const grid = document.getElementById('calendarGrid');
        grid.innerHTML = '';
        
        // Day headers
        const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        dayHeaders.forEach(day => {
            const header = document.createElement('div');
            header.className = 'calendar-day-header';
            header.textContent = day;
            grid.appendChild(header);
        });
        
        // Empty cells for days before month starts
        for (let i = 0; i < firstDay; i++) {
            const empty = document.createElement('div');
            empty.className = 'calendar-day empty';
            grid.appendChild(empty);
        }
        
        // Days of the month
        for (let day = 1; day <= daysInMonth; day++) {
            const dayCell = document.createElement('div');
            dayCell.className = 'calendar-day';
            dayCell.textContent = day;
            dayCell.dataset.date = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            dayCell.addEventListener('click', () => selectDate(dayCell));
            grid.appendChild(dayCell);
        }
    }

    async function loadCycleData() {
        try {
            // Load cycles
            const cyclesResponse = await fetch('/api/get-cycles');
            const cyclesData = await cyclesResponse.json();
            
            // Load cycle phase and predictions
            let phaseData = null;
            let predictionData = null;
            
            try {
                const phaseResponse = await fetch('/api/get-cycle-phase');
                if (phaseResponse.ok) {
                    phaseData = await phaseResponse.json();
                    console.log('Phase data received:', phaseData);
                } else {
                    const errorData = await phaseResponse.json();
                    console.error('Phase API error:', phaseResponse.status, errorData);
                }
            } catch (e) {
                console.error('Error fetching phase data:', e);
            }
            
            try {
                const predictionResponse = await fetch('/api/predict-cycle');
                if (predictionResponse.ok) {
                    predictionData = await predictionResponse.json();
                    console.log('Prediction data received:', predictionData);
                } else {
                    const errorData = await predictionResponse.json();
                    console.error('Prediction API error:', predictionResponse.status, errorData);
                }
            } catch (e) {
                console.error('Error fetching prediction data:', e);
            }
            
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            
            // Mark period days
            if (cyclesData.success && cyclesData.cycles) {
                cyclesData.cycles.forEach(cycle => {
                    const startDate = new Date(cycle.start_date);
                    const periodLength = parseInt(cycle.period_length) || 5;
                    const endDate = cycle.end_date ? new Date(cycle.end_date) : new Date(startDate.getTime() + (periodLength - 1) * 24 * 60 * 60 * 1000);
                    
                    // Mark all period days
                    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                        const dateStr = d.toISOString().split('T')[0];
                        const dayCell = document.querySelector(`[data-date="${dateStr}"]`);
                        if (dayCell && d.getMonth() === month && d.getFullYear() === year) {
                            dayCell.classList.add('period-day');
                            console.log('Marking period day:', dateStr);
                        }
                    }
                });
            }
            
            // Mark fertility windows for ALL cycles that have dates in current month view
            if (cyclesData.success && cyclesData.cycles && cyclesData.cycles.length > 0) {
                console.log('=== CALCULATING FERTILITY WINDOWS FOR ALL CYCLES ===');
                
                cyclesData.cycles.forEach((cycle, cycleIndex) => {
                    try {
                        const cycleStart = new Date(cycle.start_date + 'T00:00:00');
                        const cycleLength = parseInt(cycle.cycle_length) || 28;
                        
                        // Calculate ovulation date for this cycle (14 days before next period, or cycle_length - 14 days from start)
                        const ovulationDay = cycleLength - 14;
                        const ovulationDate = new Date(cycleStart);
                        ovulationDate.setDate(ovulationDate.getDate() + ovulationDay);
                        
                        // Fertile window: 5 days before ovulation to 1 day after
                        const fertileStart = new Date(ovulationDate);
                        fertileStart.setDate(fertileStart.getDate() - 5);
                        const fertileEnd = new Date(ovulationDate);
                        fertileEnd.setDate(fertileEnd.getDate() + 1);
                        
                        console.log(`Cycle ${cycleIndex + 1}: Start ${cycleStart.toISOString().split('T')[0]}, Fertile ${fertileStart.toISOString().split('T')[0]} to ${fertileEnd.toISOString().split('T')[0]}, Ovulation ${ovulationDate.toISOString().split('T')[0]}`);
                        
                        // Mark fertile window days that fall in current month view
                        for (let d = new Date(fertileStart); d <= fertileEnd; d.setDate(d.getDate() + 1)) {
                            const dateStr = d.toISOString().split('T')[0];
                            const dayCell = document.querySelector(`[data-date="${dateStr}"]`);
                            const cellMonth = d.getMonth();
                            const cellYear = d.getFullYear();
                            
                            // Check if date is in current month view
                            if (dayCell && cellMonth === month && cellYear === year) {
                                // Only mark if not already a period day
                                if (!dayCell.classList.contains('period-day')) {
                                    // Mark ovulation day specially
                                    const ovulationStr = ovulationDate.toISOString().split('T')[0];
                                    if (dateStr === ovulationStr) {
                                        dayCell.classList.add('ovulation-day');
                                        dayCell.style.setProperty('background', '#FFA500', 'important');
                                        dayCell.style.setProperty('border', '3px solid #FF8C00', 'important');
                                        dayCell.style.setProperty('color', '#8B4513', 'important');
                                        dayCell.style.setProperty('font-weight', 'bold', 'important');
                                        dayCell.style.setProperty('box-shadow', '0 0 20px rgba(255, 165, 0, 0.9), 0 0 30px rgba(255, 140, 0, 0.7)', 'important');
                                        dayCell.title = 'Ovulation Day - Peak Fertility';
                                        console.log('✓ Marked ovulation day:', dateStr);
                                    } else {
                                        // Only add fertile-day if not already ovulation-day
                                        if (!dayCell.classList.contains('ovulation-day')) {
                                            dayCell.classList.add('fertile-day');
                                            dayCell.style.setProperty('background', '#90EE90', 'important');
                                            dayCell.style.setProperty('border', '2px solid #228B22', 'important');
                                            dayCell.style.setProperty('color', '#006400', 'important');
                                            dayCell.style.setProperty('font-weight', 'bold', 'important');
                                            dayCell.style.setProperty('box-shadow', '0 2px 8px rgba(34, 139, 34, 0.5)', 'important');
                                            dayCell.title = 'Fertile Window';
                                            console.log('✓ Marked fertile day:', dateStr);
                                        }
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.error(`Error processing cycle ${cycleIndex + 1}:`, e);
                    }
                });
            }
            
            // Also mark fertility window from API if available (for current/latest cycle)
            if (phaseData && phaseData.success && phaseData.phase_info) {
                const phaseInfo = phaseData.phase_info;
                console.log('=== ALSO MARKING LATEST CYCLE FERTILITY WINDOW ===');
                
                const fertileStart = new Date(phaseInfo.fertile_window_start + 'T00:00:00');
                const fertileEnd = new Date(phaseInfo.fertile_window_end + 'T00:00:00');
                const ovulationDate = new Date(phaseInfo.ovulation_date + 'T00:00:00');
                
                // Mark fertile window days
                for (let d = new Date(fertileStart); d <= fertileEnd; d.setDate(d.getDate() + 1)) {
                    const dateStr = d.toISOString().split('T')[0];
                    const dayCell = document.querySelector(`[data-date="${dateStr}"]`);
                    const cellMonth = d.getMonth();
                    const cellYear = d.getFullYear();
                    
                    if (dayCell && cellMonth === month && cellYear === year) {
                        if (!dayCell.classList.contains('period-day')) {
                            const ovulationStr = ovulationDate.toISOString().split('T')[0];
                            if (dateStr === ovulationStr) {
                                dayCell.classList.add('ovulation-day');
                                dayCell.style.setProperty('background', '#FFA500', 'important');
                                dayCell.style.setProperty('border', '3px solid #FF8C00', 'important');
                                dayCell.style.setProperty('color', '#8B4513', 'important');
                                dayCell.style.setProperty('font-weight', 'bold', 'important');
                                dayCell.style.setProperty('box-shadow', '0 0 20px rgba(255, 165, 0, 0.9), 0 0 30px rgba(255, 140, 0, 0.7)', 'important');
                                dayCell.title = 'Ovulation Day - Peak Fertility';
                            } else if (!dayCell.classList.contains('ovulation-day')) {
                                dayCell.classList.add('fertile-day');
                                dayCell.style.setProperty('background', '#90EE90', 'important');
                                dayCell.style.setProperty('border', '2px solid #228B22', 'important');
                                dayCell.style.setProperty('color', '#006400', 'important');
                                dayCell.style.setProperty('font-weight', 'bold', 'important');
                                dayCell.style.setProperty('box-shadow', '0 2px 8px rgba(34, 139, 34, 0.5)', 'important');
                                dayCell.title = 'Fertile Window';
                            }
                        }
                    }
                }
            }
            
            // Calculate and mark fertility window for next predicted cycle
            if (predictionData && predictionData.success && predictionData.predicted_date && cyclesData.success && cyclesData.cycles && cyclesData.cycles.length > 0) {
                try {
                    const predictedPeriodStart = new Date(predictionData.predicted_date);
                    
                    // Calculate average cycle length
                    let cycleLengths = [];
                    cyclesData.cycles.forEach(cycle => {
                        try {
                            const cl = parseInt(cycle.cycle_length) || 28;
                            if (20 <= cl && cl <= 45) {
                                cycleLengths.push(cl);
                            }
                        } catch (e) {}
                    });
                    const avgCycleLength = cycleLengths.length > 0 ? 
                        Math.round(cycleLengths.reduce((a, b) => a + b, 0) / cycleLengths.length) : 28;
                    
                    // Calculate ovulation for next cycle (14 days before next period, or cycle_length - 14 days from period start)
                    const ovulationDay = avgCycleLength - 14;
                    const nextOvulationDate = new Date(predictedPeriodStart);
                    nextOvulationDate.setDate(nextOvulationDate.getDate() + ovulationDay);
                    
                    // Fertile window: 5 days before ovulation to 1 day after
                    const nextFertileStart = new Date(nextOvulationDate);
                    nextFertileStart.setDate(nextFertileStart.getDate() - 5);
                    const nextFertileEnd = new Date(nextOvulationDate);
                    nextFertileEnd.setDate(nextFertileEnd.getDate() + 1);
                    
                    console.log('Next cycle fertile window:', nextFertileStart, 'to', nextFertileEnd);
                    console.log('Next ovulation:', nextOvulationDate);
                    
                    // Mark next cycle fertile window days
                    for (let d = new Date(nextFertileStart); d <= nextFertileEnd; d.setDate(d.getDate() + 1)) {
                        const dateStr = d.toISOString().split('T')[0];
                        const dayCell = document.querySelector(`[data-date="${dateStr}"]`);
                        const cellMonth = d.getMonth();
                        const cellYear = d.getFullYear();
                        
                        if (dayCell && cellMonth === month && cellYear === year) {
                            // Only mark if not already period day or predicted period
                            if (!dayCell.classList.contains('period-day') && !dayCell.classList.contains('predicted-period')) {
                                // Mark ovulation day
                                const nextOvulationStr = nextOvulationDate.toISOString().split('T')[0];
                                if (dateStr === nextOvulationStr) {
                                    dayCell.classList.add('ovulation-day');
                                    // Force styles with inline CSS - brighter orange
                                    dayCell.style.setProperty('background', '#FFA500', 'important');
                                    dayCell.style.setProperty('border', '3px solid #FF8C00', 'important');
                                    dayCell.style.setProperty('color', '#8B4513', 'important');
                                    dayCell.style.setProperty('font-weight', 'bold', 'important');
                                    dayCell.style.setProperty('box-shadow', '0 0 20px rgba(255, 165, 0, 0.9), 0 0 30px rgba(255, 140, 0, 0.7)', 'important');
                                    dayCell.title = 'Ovulation Day - Peak Fertility (Next Cycle)';
                                } else {
                                    dayCell.classList.add('fertile-day');
                                    // Force styles with inline CSS - brighter green
                                    dayCell.style.setProperty('background', '#90EE90', 'important');
                                    dayCell.style.setProperty('border', '2px solid #228B22', 'important');
                                    dayCell.style.setProperty('color', '#006400', 'important');
                                    dayCell.style.setProperty('font-weight', 'bold', 'important');
                                    dayCell.style.setProperty('box-shadow', '0 2px 8px rgba(34, 139, 34, 0.5)', 'important');
                                    dayCell.title = 'Fertile Window (Next Cycle)';
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error calculating next cycle fertility window:', e);
                }
            }
            
            // Mark predicted period (highlighted prominently)
            if (predictionData && predictionData.success && predictionData.predicted_date) {
                const predictedDate = new Date(predictionData.predicted_date);
                const predictedPeriodLength = 5; // Default period length
                const confidence = predictionData.confidence ? Math.round(predictionData.confidence * 100) : 'N/A';
                
                // Mark predicted period days (highlight them prominently)
                for (let i = 0; i < predictedPeriodLength; i++) {
                    const periodDay = new Date(predictedDate);
                    periodDay.setDate(periodDay.getDate() + i);
                    const dateStr = periodDay.toISOString().split('T')[0];
                    const dayCell = document.querySelector(`[data-date="${dateStr}"]`);
                    if (dayCell && periodDay.getMonth() === month && periodDay.getFullYear() === year) {
                        // Only mark as predicted if not already a period day
                        if (!dayCell.classList.contains('period-day')) {
                            dayCell.classList.add('predicted-period');
                            dayCell.title = `Predicted Period Day ${i + 1} (${confidence}% confidence)`;
                            console.log('Marking predicted period:', dateStr);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Error loading cycle data:', error);
        }
    }

    function selectDate(cell) {
        document.querySelectorAll('.calendar-day.selected').forEach(c => c.classList.remove('selected'));
        cell.classList.add('selected');
        selectedDate = cell.dataset.date;
    }
</script>
{% endblock %}

